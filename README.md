# 수학과프로그래밍_개인 project : 저격 홀덤
# 목차
- [프로젝트 선정 이유](#프로젝트-선정-이유)
- [게임 규칙 소개](#게임-규칙-소개)
- [코드 설명](#코드-설명)
- [실행 결과](#실행-결과)
- [피드백](#피드백)

# 프로젝트 선정 이유
#### 
위 게임은 최근 방영된 '데블스플랜2'라는 프로그램에서 패자부활전에 등장하였던 게임입니다. 평소, 두뇌 추리 프로그램을 즐겨 보던 제가 '데블스플랜2' 라는 프로그램을 접하게 되었는데, 해당 프로그램에서 나온 많은 게임들 중에서도 '저격 홀덤'이라는 게임이 굉장히 인상깊게 남았습니다. 그래서, 프로젝트 과제가 생길 때부터 이 게임을 구현해야겠다는 생각을 항상 하였습니다.

# 게임 규칙 소개
####
먼저, 해당 게임은 텍사스 홀덤을 기본적인 구조로 사용한다는 점을 알려드립니다. 위 게임은 더 많은 인원으로 시작해도 상관없지만, 4명에서 게임을 시작할 때가 가장 흥미로울 것이라고 예측되어 게임 시작 인원이 4명이 상태를 구현하였습니다. 가장 먼저, 숫자 카드 1부터 10까지를 총 4세트 준비합니다. 이후, 공통으로 사용할 수 있는 카드 4장을 뽑아서 모두가 볼 수 있는 공개 카드로 설정하고 2장씩 개인에게 카드를 나누어주어 비공개카드로 지정하고 본인만 볼 수 있도록 합니다. 이제, 칩 상황에 대해서 말씀드리겠습니다. 모든 플레이어는 60개의 칩씩 초기에 가지고 있습니다. 배팅을 할 때에는 최소 1개부터 본인이 가지고 있는 칩 수까지 배팅이 가능하며, 이 때, 1개를 배팅한다는 것은 해당라운드를 포기한다는 것을 의미합니다. 즉, 2개부터가 라운드에 참여한다는 것을 알 수 있습니다. 그렇게, 카드 분배가 모두 종료된 후에는 플레이어의 순서대로 배팅을 1번씩만 진행합니다. 실제 게임에서는 본인의 카드패를 본인만 확인할 수 있지만, Python에서는 그럴 수가 없으므로, 터미널에서 한명씩 개인카드를 확인하도록 합니다. 그렇게, 개인 비공개 카드까지 확인이 종료된 후에는 저격라운드를 시작합니다. 플레이어는 공개 카드를 토대로 하여 저격할 조합을 한개씩 선택합니다. 이 때, 특정 플레이어들의 패에 저격된 조합이 포함되어 있다면 그 조합은 사용할 수 없게 됩니다. 이런 식으로 저격라운드까지 종료가 된 후에는 카드 조합의 우위 순서대로 승자가 결정됩니다. 카드 우위 순서는 다음과 같습니다. 포카드 > 풀하우스 > 스트레이트 > 트리플 > 투페어 > 원페어 > 하이카드 순서대로 우위를 점하게 되고, 동일 조합에서는 카드의 넘버가 더 높은 쪽이 이기게 됩니다. 위 게임은 한명이 남을 때까지 진행해야 하므로, 어떤 플레이어가 75개 칩 이상을 보유하게 되면 이 게임에서 생존하게 됩니다. 이 때, 생존한 플레이어의 칩 수가 75개 이상이면 그 칩 수에서 75개를 제외한 나머지 칩 수를 남아있는 플레이어들에게 균등하게 분배합니다. 나머지 칩 수가 자연수가 아닐 경우에는 버림의 방식을 차용하여 분배합니다. 이렇게, 게임은 1명이 남을 때까지 진행합니다.

# 코드 설명
가장 먼저, import문을 활용하여 카드를 무작위하게 분배해 줄 random과 카드 개수를 카운팅 해줄 Counter를 불러옵니다.

**1. 카드 덱 생성 및 카드 조합 등록 함수 설명**

![스크린샷 2025-06-22 오전 11 34 08](https://github.com/user-attachments/assets/7c36e2fd-e75c-4ab4-9806-16764c14e449)

- 카드 덱인 1부터 10까지의 세트를 총 4개 생성시킨 뒤, 해당 카드 덱으로 나올 수 있는 조합들을 규칙에 알맞게 등록시킵니다.

**2. 플레이어 클래스 설명**

![스크린샷 2025-06-22 오전 11 34 28](https://github.com/user-attachments/assets/0bd43761-82de-4ed0-83a6-041508c39cb3)

- 각 플레이어들에 대한 정보들을 입력할 수 있는 클래스를 생성합니다.

**3. 메인 클래스 설명**

- 이 코드는 SniperHoldem이라는 메인 클래스를 통해 게임이 진행됩니다. 이 클래스는 많은 함수들로 구성되어있고 순서대로 설명드리겠습니다.

![스크린샷 2025-06-22 오전 11 35 43](https://github.com/user-attachments/assets/6316ad83-cdc0-4703-a1fc-6d3aee7a5d45)

- 먼저, 이 게임을 진행하는 데에 있어서 기본적으로 필요한 정보들을 선언합니다. 이후, 공통으로 사용할 수 있는 공개 카드 4장, 개인이 사용할 수 있는 비공개 카드를 2장씩 분배해주는 함수를 선언합니다. 또한, 배팅을 할 수 있는 함수까지 만들어줍니다. 이 때, 게임의 규칙대로 배팅 칩의 개수를 1개로 입력하면 칩의 수를 1개 소모하면서 게임을 포기한다는 것으로 간주됩니다.

![스크린샷 2025-06-22 오전 11 36 52](https://github.com/user-attachments/assets/4035ce99-26e1-4f73-8fbb-b1eea7cc82e5)

![스크린샷 2025-06-22 오전 11 38 00](https://github.com/user-attachments/assets/313aaab7-fea0-40df-bcb1-df05e5cdf7fe)

- 이후, 각 플레이어마다 공개 카드를 기반으로 하여, 저격을 진행하고 저격에 성공한 조합이 있다면 저격 성공을 알려주고 어떤 것도 맞추지 못하였다면 각 플레이어의 조합들을 비교하는 쪽으로 넘어가도록 설정하였습니다.

![스크린샷 2025-06-22 오전 11 38 45](https://github.com/user-attachments/assets/e73fe124-f269-4ce3-a135-a18f2c2d10ae)

- 앞선 함수에서 저격에 성공한 조합이 있다면, 라운드 결과 처리 함수에서는 저격된 조합이 자동적으로 제외되고, 승자에게 배팅된 칩을 모두 제공하는 것까지 구현하였습니다.

![스크린샷 2025-06-22 오후 7 38 38](https://github.com/user-attachments/assets/f8601610-883d-43d4-91ac-a0bd78874ce2)

- 라운드가 종료된 후에는, 보유한 칩의 개수를 통해 탈출이 가능한 플레이어 혹은 탈락하는 플레이어를 골라내야 하기 때문에 해당 시스템을 반영한 함수를 구현하였습니다. 그리고, 다음 라운드도 진행하여야 하기 때문에 라운드가 종료된 뒤에 상태를 보여주는 테이블이 나오도록 설정하였습니다.

![스크린샷 2025-06-22 오전 11 39 24](https://github.com/user-attachments/assets/48d222e6-e22b-44f8-a600-5944b59e285f)=

- 게임을 시작하는 함수는 라운드가 시작하고 플레이어의 인원 수대로 게임이 진행되도록 설정하였습니다.


# 실행 결과

이제 게임을 실행하여 어떻게 진행되는지에 대해서 설명드리겠습니다.

![스크린샷 2025-06-22 오후 7 41 19](https://github.com/user-attachments/assets/60719086-abcc-43f3-909b-1db09ab4bd87)

- 현재 칩 상태와 공유되는 카드인 공개 카드를 알 수 있고, 한 명씩 enter키를 눌러 본인의 비공개카드를 확인할 수 있습니다.

![스크린샷 2025-06-22 오후 7 42 12](https://github.com/user-attachments/assets/c9dff39c-4f41-4277-90ef-261d8d94aa90)

- 플레이어 각자의 카드 패를 확인한 후, 배팅을 진행합니다.

![스크린샷 2025-06-22 오후 7 43 36](https://github.com/user-attachments/assets/4382d106-10b4-45ae-8dab-2810f79088f7)

- 위와 같이 저격라운드를 진행하는데, 저격이 모두 실패하였으므로 승자가 도출되고 해당 승자의 칩 수가 75개 이상이 되었으므로, 이 게임에서 탈출과 동시에 남은 칩을 남은 플레이어들에게 균등 분배합니다. 이후, 탈출한 플레이어를 제외하고 다음 라운드를 진행합니다.

![스크린샷 2025-06-22 오후 7 45 08](https://github.com/user-attachments/assets/ca5b92d1-3833-40da-9842-e84ba5fd7fcb)

![스크린샷 2025-06-22 오후 7 45 20](https://github.com/user-attachments/assets/18cff677-4639-4bb8-9409-70fd0a714001)

- 2라운드에서도 1라운드와 동일하게 개인의 비공개카드를 확인한 후 배팅을 진행한 뒤, 저격라운드를 시작합니다. 저격라운드에서 저격이 성공하면 해당 조합이 제외된다는 사실을 터미널에서 확인할 수 있습니다. 이 때, 유의할 점으로는 터미널에서 정해진 양식대로 저격 조합을 입력하지 않으면 오류가 발생하기 때문에 올바른 양식대로 저격 조합을 입력해야 합니다. 또 한명의 플레이어 칩 수가 75개 이상이 되었으므로, 해당 플레이어가 탈출에 성공하였습니다. 그렇기에, 3라운드는 남은 칩을 분배받은 뒤, 2명의 플레이어끼리 게임을 진행합니다.

![스크린샷 2025-06-22 오후 7 47 41](https://github.com/user-attachments/assets/8ef9a360-f709-4344-80e9-b01a7d8cf06b)

![스크린샷 2025-06-22 오후 7 47 54](https://github.com/user-attachments/assets/bff6bb29-ddae-43ce-8e53-0520be469b82)

![스크린샷 2025-06-22 오후 7 48 56](https://github.com/user-attachments/assets/439e6cb6-63b7-43f6-b256-83e029db9c99)

![스크린샷 2025-06-22 오후 7 49 10](https://github.com/user-attachments/assets/e9996d8c-fb3f-4fd0-9c00-658bde033f01)

- 3,4라운드도 앞선 라운드와 마찬가지로 진행됩니다. 이 게임의 흥미로운 요소는 위와 같이 지고 있는 상황에서 한 순간의 배팅으로 인하여 게임의 전세를 역전시킬 수 있다는 것을 3,4라운드를 통해서 알 수 있습니다.

![스크린샷 2025-06-22 오후 7 52 03](https://github.com/user-attachments/assets/dd42840d-55c4-45ba-aeff-d90984bcc978)

![스크린샷 2025-06-22 오후 7 52 17](https://github.com/user-attachments/assets/e08b5bfd-e11a-45f3-8efa-279dee4a1f2f)

- 이렇게 마지막 라운드가 진행이 되어서 최종 승자가 나오게 되고 플레이어 4는 칩의 개수가 0개로 남기 때문에 최종 탈락하게 됩니다. 만약, 이 상황에서 플레이어 4의 남은 칩 수가 0개가 아니였어도 다른 3명의 플레이어가 탈출에 성공했기 때문에 자동적으로 탈락을 확정짓습니다.


# 피드백
####
이 게임을 코드로 구현하는 데에 있어서 아쉬웠던 부분을 피드백으로 남기겠습니다. 가장 먼저, enter키를 눌러서 본인의 비공개카드를 확인하여야 한다는 점이 아쉬운 부분으로 남는 것 같습니다. 실제 게임에서는 본인의 비공개카드는 본인만이 확인할 수 있는 것이 너무 명확한 데 이 부분을 코드로 구현하기가 수월하지 않았던 것 같습니다. 두 번째로는, 게임이 끝나는 라운드에서는 승리 플레이어의 남은 칩을 분배받을 필요가 없는데 이 부분을 적절히 if문과 for문을 활용하지 못하여 구현하지 못했다는 것이 아쉬웠던 부분이었습니다. 마지막으로는, 같은 파워를 가지고 있는 조합 중에서 문제가 발생할 수 있는 부분, 예를 들면, 4 원페어, 6 투페어처럼 서로 같기 때문에 나머지 카드들끼리 비교해야 하는 상황을 명확하게 구현하지 못했다는 점이 오점으로 남습니다. 한 가지 상황을 예시로 들자면, 같은 4 원페어끼리 충돌하면 공개 카드와 비공개 카드들을 합친 카드 셋에서 가장 큰 숫자끼리 비교를 진행합니다. 하지만, 가장 큰 숫자까지도 동일하다면, 다시 다른 카드로 비교를 해야할 지 혹은 무승부로 처리해야할지에 대한 기준이 명확히 정립되지 않아서 코드를 구현하는데에 쉽지 않았던 것 같습니다.
